<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--cubical-compatible</a> <a id="305" class="Pragma">--safe</a> <a id="312" class="Symbol">#-}</a>

<a id="317" class="Keyword">module</a> <a id="324" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="342" class="Keyword">where</a>

<a id="349" class="Keyword">open</a> <a id="354" class="Keyword">import</a> <a id="361" href="Algebra.html" class="Module">Algebra</a>
<a id="369" class="Keyword">open</a> <a id="374" class="Keyword">import</a> <a id="381" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="397" class="Symbol">as</a> <a id="400" class="Module">Fin</a>     <a id="408" class="Keyword">using</a> <a id="414" class="Symbol">(</a><a id="415" href="Data.Fin.Base.html#1312" class="Datatype">Fin</a><a id="418" class="Symbol">)</a>
<a id="420" class="Keyword">open</a> <a id="425" class="Keyword">import</a> <a id="432" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="448" class="Symbol">as</a> <a id="451" class="Module">Vec</a>     <a id="459" class="Keyword">using</a> <a id="465" class="Symbol">(</a><a id="466" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a><a id="469" class="Symbol">;</a> <a id="471" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">_∷_</a><a id="474" class="Symbol">;</a> <a id="476" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a><a id="478" class="Symbol">)</a>
<a id="480" class="Keyword">open</a> <a id="485" class="Keyword">import</a> <a id="492" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="508" class="Symbol">as</a> <a id="511" class="Module">List</a>    <a id="519" class="Keyword">using</a> <a id="525" class="Symbol">(</a><a id="526" href="Agda.Builtin.List.html#130" class="Datatype">List</a><a id="530" class="Symbol">;</a> <a id="532" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">_∷_</a><a id="535" class="Symbol">;</a> <a id="537" href="Data.List.Base.html#7375" class="InductiveConstructor">[]</a><a id="539" class="Symbol">)</a>
<a id="541" class="Keyword">open</a> <a id="546" class="Keyword">import</a> <a id="553" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="569" class="Symbol">as</a> <a id="572" class="Module">Maybe</a>   <a id="580" class="Keyword">using</a> <a id="586" class="Symbol">(</a><a id="587" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a><a id="592" class="Symbol">;</a> <a id="594" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a><a id="598" class="Symbol">;</a> <a id="600" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a><a id="607" class="Symbol">;</a> <a id="609" href="Data.Maybe.Base.html#1661" class="Function">fromMaybe</a><a id="618" class="Symbol">)</a>
<a id="620" class="Keyword">open</a> <a id="625" class="Keyword">import</a> <a id="632" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>              <a id="659" class="Keyword">using</a> <a id="665" class="Symbol">(</a><a id="666" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="667" class="Symbol">;</a> <a id="669" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a><a id="672" class="Symbol">;</a> <a id="674" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a><a id="678" class="Symbol">;</a> <a id="680" href="Data.Nat.Base.html#1310" class="Primitive Operator">_&lt;ᵇ_</a><a id="684" class="Symbol">)</a>
<a id="686" class="Keyword">open</a> <a id="691" class="Keyword">import</a> <a id="698" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>             <a id="725" class="Keyword">using</a> <a id="731" class="Symbol">(</a><a id="732" href="Agda.Builtin.Bool.html#156" class="Datatype">Bool</a><a id="736" class="Symbol">;</a> <a id="738" href="Data.Bool.Base.html#1292" class="Function Operator">if_then_else_</a><a id="751" class="Symbol">;</a> <a id="753" href="Agda.Builtin.Bool.html#181" class="InductiveConstructor">true</a><a id="757" class="Symbol">;</a> <a id="759" href="Agda.Builtin.Bool.html#175" class="InductiveConstructor">false</a><a id="764" class="Symbol">)</a>
<a id="766" class="Keyword">open</a> <a id="771" class="Keyword">import</a> <a id="778" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>             <a id="805" class="Keyword">using</a> <a id="811" class="Symbol">(</a><a id="812" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a><a id="813" class="Symbol">)</a>
<a id="815" class="Keyword">open</a> <a id="820" class="Keyword">import</a> <a id="827" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="844" class="Symbol">as</a> <a id="847" class="Module">String</a> <a id="854" class="Keyword">using</a> <a id="860" class="Symbol">(</a><a id="861" href="Agda.Builtin.String.html#318" class="Postulate">String</a><a id="867" class="Symbol">;</a> <a id="869" href="Data.String.Base.html#2400" class="Function Operator">_++_</a><a id="873" class="Symbol">;</a> <a id="875" href="Data.String.Base.html#2860" class="Function">parens</a><a id="881" class="Symbol">)</a>
<a id="883" class="Keyword">open</a> <a id="888" class="Keyword">import</a> <a id="895" href="Data.Product.Base.html" class="Module">Data.Product.Base</a>          <a id="922" class="Keyword">using</a> <a id="928" class="Symbol">(</a><a id="929" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">_,_</a><a id="932" class="Symbol">;</a> <a id="934" href="Data.Product.Base.html#636" class="Field">proj₁</a><a id="939" class="Symbol">)</a>
<a id="941" class="Keyword">open</a> <a id="946" class="Keyword">import</a> <a id="953" href="Function.Base.html" class="Module">Function.Base</a>
<a id="967" class="Keyword">open</a> <a id="972" class="Keyword">import</a> <a id="979" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="1007" class="Keyword">open</a> <a id="1012" class="Keyword">import</a> <a id="1019" href="Reflection.html" class="Module">Reflection</a>
<a id="1030" class="Keyword">open</a> <a id="1035" class="Keyword">import</a> <a id="1042" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="1066" class="Keyword">open</a> <a id="1071" class="Keyword">import</a> <a id="1078" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a> <a id="1098" class="Symbol">as</a> <a id="1101" class="Module">Term</a>
<a id="1106" class="Keyword">open</a> <a id="1111" class="Keyword">import</a> <a id="1118" href="Reflection.AST.AlphaEquality.html" class="Module">Reflection.AST.AlphaEquality</a>
<a id="1147" class="Keyword">open</a> <a id="1152" class="Keyword">import</a> <a id="1159" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="1179" class="Symbol">as</a> <a id="1182" class="Module">Name</a>
<a id="1187" class="Keyword">open</a> <a id="1192" class="Keyword">import</a> <a id="1199" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>
<a id="1221" class="Keyword">open</a> <a id="1226" class="Keyword">import</a> <a id="1233" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1253" class="Keyword">open</a> <a id="1258" class="Keyword">import</a> <a id="1265" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1286" class="Keyword">import</a> <a id="1293" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1313" class="Symbol">as</a> <a id="1316" class="Module">Vec</a>

<a id="1321" class="Keyword">open</a> <a id="1326" class="Keyword">import</a> <a id="1333" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1365" class="Keyword">renaming</a> <a id="1374" class="Symbol">(</a><a id="1375" href="Tactic.RingSolver.NonReflective.html#3025" class="Function">solve</a> <a id="1381" class="Symbol">to</a> <a id="1384" class="Function">solver</a><a id="1390" class="Symbol">)</a>
<a id="1392" class="Keyword">open</a> <a id="1397" class="Keyword">import</a> <a id="1404" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1449" class="Keyword">open</a> <a id="1454" class="Keyword">import</a> <a id="1461" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1491" class="Symbol">as</a> <a id="1494" class="Module">NatSet</a>

<a id="1502" class="Keyword">open</a> <a id="1507" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1288" class="Module">AlmostCommutativeRing</a>

<a id="1530" class="Comment">------------------------------------------------------------------------</a>
<a id="1603" class="Comment">-- Utilities</a>

<a id="1617" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1627" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a> <a id="1634" class="Symbol">:</a> <a id="1636" href="Agda.Primitive.html#320" class="Primitive">Set</a>
  <a id="1642" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a> <a id="1649" class="Symbol">=</a> <a id="1651" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="1653" class="Symbol">→</a> <a id="1655" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1661" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1669" href="Tactic.RingSolver.html#1669" class="Function">getVisible</a> <a id="1680" class="Symbol">:</a> <a id="1682" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="1686" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="1691" class="Symbol">→</a> <a id="1693" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1699" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="1706" href="Tactic.RingSolver.html#1669" class="Function">getVisible</a> <a id="1717" class="Symbol">(</a><a id="1718" href="Agda.Builtin.Reflection.html#3715" class="InductiveConstructor">arg</a> <a id="1722" class="Symbol">(</a><a id="1723" href="Agda.Builtin.Reflection.html#3620" class="InductiveConstructor">arg-info</a> <a id="1732" href="Agda.Builtin.Reflection.html#2745" class="InductiveConstructor">visible</a> <a id="1740" class="Symbol">_)</a> <a id="1743" href="Tactic.RingSolver.html#1743" class="Bound">x</a><a id="1744" class="Symbol">)</a> <a id="1746" class="Symbol">=</a> <a id="1748" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="1753" href="Tactic.RingSolver.html#1743" class="Bound">x</a>
  <a id="1757" href="Tactic.RingSolver.html#1669" class="CatchallClause Function">getVisible</a><a id="1767" class="CatchallClause"> </a><a id="1768" class="CatchallClause Symbol">_</a>                            <a id="1797" class="Symbol">=</a> <a id="1799" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1810" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="1825" class="Symbol">:</a> <a id="1827" class="Symbol">∀</a> <a id="1829" href="Tactic.RingSolver.html#1829" class="Bound">n</a> <a id="1831" class="Symbol">→</a> <a id="1833" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="1838" class="Symbol">→</a> <a id="1840" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1846" class="Symbol">(</a><a id="1847" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="1851" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="1856" href="Tactic.RingSolver.html#1829" class="Bound">n</a><a id="1857" class="Symbol">)</a>
  <a id="1861" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="1876" href="Tactic.RingSolver.html#1876" class="Bound">n</a> <a id="1878" class="Symbol">(</a><a id="1879" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="1883" class="Symbol">_</a> <a id="1885" href="Tactic.RingSolver.html#1885" class="Bound">xs</a><a id="1887" class="Symbol">)</a> <a id="1889" class="Symbol">=</a> <a id="1891" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="1901" href="Data.Vec.Base.html#8948" class="Function">Vec.reverse</a>
    <a id="1917" class="Symbol">(</a><a id="1918" href="Data.List.Base.html#4426" class="Function">List.foldl</a> <a id="1929" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="1931" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="1933" class="Symbol">(</a><a id="1934" href="Data.List.Base.html#1705" class="Function">List.mapMaybe</a> <a id="1948" href="Tactic.RingSolver.html#1669" class="Function">getVisible</a> <a id="1959" href="Tactic.RingSolver.html#1885" class="Bound">xs</a><a id="1961" class="Symbol">)</a> <a id="1963" href="Tactic.RingSolver.html#1876" class="Bound">n</a><a id="1964" class="Symbol">)</a>
    <a id="1970" class="Keyword">where</a>
    <a id="1980" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="1982" class="Symbol">:</a> <a id="1984" class="Symbol">(∀</a> <a id="1987" href="Tactic.RingSolver.html#1987" class="Bound">n</a> <a id="1989" class="Symbol">→</a> <a id="1991" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="1997" class="Symbol">(</a><a id="1998" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="2002" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2007" href="Tactic.RingSolver.html#1987" class="Bound">n</a><a id="2008" class="Symbol">))</a> <a id="2011" class="Symbol">→</a> <a id="2013" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2018" class="Symbol">→</a> <a id="2020" class="Symbol">∀</a> <a id="2022" href="Tactic.RingSolver.html#2022" class="Bound">n</a> <a id="2024" class="Symbol">→</a> <a id="2026" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="2032" class="Symbol">(</a><a id="2033" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="2037" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2042" href="Tactic.RingSolver.html#2022" class="Bound">n</a><a id="2043" class="Symbol">)</a>
    <a id="2049" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="2051" href="Tactic.RingSolver.html#2051" class="Bound">xs</a> <a id="2054" href="Tactic.RingSolver.html#2054" class="Bound">x</a> <a id="2056" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>    <a id="2064" class="Symbol">=</a> <a id="2066" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2071" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>
    <a id="2078" href="Tactic.RingSolver.html#1980" class="Function">f</a> <a id="2080" href="Tactic.RingSolver.html#2080" class="Bound">xs</a> <a id="2083" href="Tactic.RingSolver.html#2083" class="Bound">x</a> <a id="2085" class="Symbol">(</a><a id="2086" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2090" href="Tactic.RingSolver.html#2090" class="Bound">n</a><a id="2091" class="Symbol">)</a> <a id="2093" class="Symbol">=</a> <a id="2095" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="2105" class="Symbol">(</a><a id="2106" href="Tactic.RingSolver.html#2083" class="Bound">x</a> <a id="2108" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷_</a><a id="2110" class="Symbol">)</a> <a id="2112" class="Symbol">(</a><a id="2113" href="Tactic.RingSolver.html#2080" class="Bound">xs</a> <a id="2116" href="Tactic.RingSolver.html#2090" class="Bound">n</a><a id="2117" class="Symbol">)</a>

    <a id="2124" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="2126" class="Symbol">:</a> <a id="2128" class="Symbol">∀</a> <a id="2130" href="Tactic.RingSolver.html#2130" class="Bound">n</a> <a id="2132" class="Symbol">→</a> <a id="2134" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="2140" class="Symbol">(</a><a id="2141" href="Data.Vec.Base.html#1086" class="Datatype">Vec</a> <a id="2145" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2150" href="Tactic.RingSolver.html#2130" class="Bound">n</a><a id="2151" class="Symbol">)</a>
    <a id="2157" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="2159" href="Agda.Builtin.Nat.html#204" class="InductiveConstructor">zero</a>     <a id="2168" class="Symbol">=</a> <a id="2170" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="2175" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a>
    <a id="2182" href="Tactic.RingSolver.html#2124" class="Function">c</a> <a id="2184" class="Symbol">(</a><a id="2185" href="Agda.Builtin.Nat.html#217" class="InductiveConstructor">suc</a> <a id="2189" class="Symbol">_</a> <a id="2191" class="Symbol">)</a> <a id="2193" class="Symbol">=</a> <a id="2195" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>
  <a id="2205" href="Tactic.RingSolver.html#1810" class="CatchallClause Function">getVisibleArgs</a><a id="2219" class="CatchallClause"> </a><a id="2220" class="CatchallClause Symbol">_</a><a id="2221" class="CatchallClause"> </a><a id="2222" class="CatchallClause Symbol">_</a> <a id="2224" class="Symbol">=</a> <a id="2226" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2237" href="Tactic.RingSolver.html#2237" class="Function">curriedTerm</a> <a id="2249" class="Symbol">:</a> <a id="2251" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a> <a id="2258" class="Symbol">→</a> <a id="2260" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="2267" href="Tactic.RingSolver.html#2237" class="Function">curriedTerm</a> <a id="2279" class="Symbol">=</a> <a id="2281" href="Data.List.Base.html#4325" class="Function">List.foldr</a> <a id="2292" href="Tactic.RingSolver.html#2333" class="Function">go</a> <a id="2295" href="Data.Vec.Reflection.html#684" class="Function">Vec.`[]</a> <a id="2303" href="Function.Base.html#1115" class="Function Operator">∘</a> <a id="2305" href="Tactic.RingSolver.Core.NatSet.html#3349" class="Function">NatSet.toList</a>
    <a id="2323" class="Keyword">where</a>
    <a id="2333" href="Tactic.RingSolver.html#2333" class="Function">go</a> <a id="2336" class="Symbol">:</a> <a id="2338" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="2340" class="Symbol">→</a> <a id="2342" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2347" class="Symbol">→</a> <a id="2349" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
    <a id="2358" href="Tactic.RingSolver.html#2333" class="Function">go</a> <a id="2361" href="Tactic.RingSolver.html#2361" class="Bound">x</a> <a id="2363" href="Tactic.RingSolver.html#2363" class="Bound">xs</a> <a id="2366" class="Symbol">=</a> <a id="2368" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="2372" href="Tactic.RingSolver.html#2361" class="Bound">x</a> <a id="2374" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a> <a id="2377" href="Data.Vec.Reflection.html#749" class="Function Operator">Vec.`∷</a> <a id="2384" href="Tactic.RingSolver.html#2363" class="Bound">xs</a>

<a id="2388" class="Comment">------------------------------------------------------------------------</a>
<a id="2461" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2496" href="Tactic.RingSolver.html#2496" class="Function">`AlmostCommutativeRing</a> <a id="2519" class="Symbol">:</a> <a id="2521" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="2526" href="Tactic.RingSolver.html#2496" class="Function">`AlmostCommutativeRing</a> <a id="2549" class="Symbol">=</a> <a id="2551" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="2555" class="Symbol">(</a><a id="2556" class="Keyword">quote</a> <a id="2562" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1288" class="Record">AlmostCommutativeRing</a><a id="2583" class="Symbol">)</a> <a id="2585" class="Symbol">(</a><a id="2586" class="Number">2</a> <a id="2588" href="Reflection.AST.Term.html#2853" class="Function Operator">⋯⟨∷⟩</a> <a id="2593" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="2595" class="Symbol">)</a>

<a id="2598" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2605" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="2623" class="Symbol">:</a> <a id="2625" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="2629" class="Keyword">where</a>
  <a id="2637" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2649" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2677" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2687" href="Tactic.RingSolver.html#2687" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2691" href="Tactic.RingSolver.html#2691" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2695" href="Tactic.RingSolver.html#2695" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2699" href="Tactic.RingSolver.html#2699" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2703" href="Tactic.RingSolver.html#2703" class="Field">sub</a> <a id="2707" class="Symbol">:</a> <a id="2709" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2715" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="2727" class="Symbol">:</a> <a id="2729" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="2734" class="Symbol">→</a> <a id="2736" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="2739" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="2744" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="2756" href="Tactic.RingSolver.html#2756" class="Bound">ring</a> <a id="2761" class="Symbol">=</a> <a id="2763" href="Agda.Builtin.Reflection.html#8591" class="Postulate">checkType</a> <a id="2773" href="Tactic.RingSolver.html#2756" class="Bound">ring</a> <a id="2778" href="Tactic.RingSolver.html#2496" class="Function">`AlmostCommutativeRing</a>

<a id="2802" class="Keyword">module</a> <a id="RingReflection"></a><a id="2809" href="Tactic.RingSolver.html#2809" class="Module">RingReflection</a> <a id="2824" class="Symbol">(</a><a id="2825" href="Tactic.RingSolver.html#2825" class="Bound">`ring</a> <a id="2831" class="Symbol">:</a> <a id="2833" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="2837" class="Symbol">)</a> <a id="2839" class="Keyword">where</a>

  <a id="2848" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2916" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2983" class="Comment">-- the required ring arguments</a>
  <a id="3016" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3064" class="Keyword">infixr</a> <a id="3071" class="Number">6</a> <a id="3073" href="Tactic.RingSolver.html#3080" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3080" href="Tactic.RingSolver.html#3080" class="Function Operator">_$ʳ_</a> <a id="3085" class="Symbol">:</a> <a id="3087" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="3092" class="Symbol">→</a> <a id="3094" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="3099" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3104" class="Symbol">→</a> <a id="3106" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3113" href="Tactic.RingSolver.html#3113" class="Bound">nm</a> <a id="3116" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3119" href="Tactic.RingSolver.html#3119" class="Bound">args</a> <a id="3124" class="Symbol">=</a> <a id="3126" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="3130" href="Tactic.RingSolver.html#3113" class="Bound">nm</a> <a id="3133" class="Symbol">(</a><a id="3134" class="Number">2</a> <a id="3136" href="Reflection.AST.Term.html#3166" class="Function Operator">⋯⟅∷⟆</a> <a id="3141" href="Tactic.RingSolver.html#2825" class="Bound">`ring</a> <a id="3147" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3151" href="Tactic.RingSolver.html#3119" class="Bound">args</a><a id="3155" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3160" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="3169" class="Symbol">:</a> <a id="3171" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3178" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="3187" class="Symbol">=</a> <a id="3189" class="Keyword">quote</a> <a id="3195" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1426" class="Field">Carrier</a> <a id="3203" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3206" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3212" href="Tactic.RingSolver.html#3212" class="Function">`refl</a> <a id="3218" class="Symbol">:</a> <a id="3220" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3227" href="Tactic.RingSolver.html#3212" class="Function">`refl</a> <a id="3233" class="Symbol">=</a> <a id="3235" class="Keyword">quote</a> <a id="3241" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2589" class="Function">refl</a> <a id="3246" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3249" class="Symbol">(</a><a id="3250" class="Number">1</a> <a id="3252" href="Reflection.AST.Term.html#3166" class="Function Operator">⋯⟅∷⟆</a> <a id="3257" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3259" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3264" href="Tactic.RingSolver.html#3264" class="Function">`sym</a> <a id="3269" class="Symbol">:</a> <a id="3271" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3276" class="Symbol">→</a> <a id="3278" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3285" href="Tactic.RingSolver.html#3264" class="Function">`sym</a> <a id="3290" href="Tactic.RingSolver.html#3290" class="Bound">x≈y</a> <a id="3294" class="Symbol">=</a> <a id="3296" class="Keyword">quote</a> <a id="3302" href="Relation.Binary.Structures.html#1622" class="Function">sym</a> <a id="3306" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3309" class="Symbol">(</a><a id="3310" class="Number">2</a> <a id="3312" href="Reflection.AST.Term.html#3166" class="Function Operator">⋯⟅∷⟆</a> <a id="3317" href="Tactic.RingSolver.html#3290" class="Bound">x≈y</a> <a id="3321" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3325" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3327" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3332" href="Tactic.RingSolver.html#3332" class="Function">`trans</a> <a id="3339" class="Symbol">:</a> <a id="3341" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3346" class="Symbol">→</a> <a id="3348" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="3353" class="Symbol">→</a> <a id="3355" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="3362" href="Tactic.RingSolver.html#3332" class="Function">`trans</a> <a id="3369" href="Tactic.RingSolver.html#3369" class="Bound">x≈y</a> <a id="3373" href="Tactic.RingSolver.html#3373" class="Bound">y≈z</a> <a id="3377" class="Symbol">=</a> <a id="3379" class="Keyword">quote</a> <a id="3385" href="Relation.Binary.Structures.html#1648" class="Function">trans</a> <a id="3391" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3394" class="Symbol">(</a><a id="3395" class="Number">3</a> <a id="3397" href="Reflection.AST.Term.html#3166" class="Function Operator">⋯⟅∷⟆</a> <a id="3402" href="Tactic.RingSolver.html#3369" class="Bound">x≈y</a> <a id="3406" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3410" href="Tactic.RingSolver.html#3373" class="Bound">y≈z</a> <a id="3414" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3418" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3420" class="Symbol">)</a>

  <a id="3425" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3491" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3558" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3616" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="3637" class="Symbol">:</a> <a id="3639" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="3642" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a>
  <a id="3662" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="3683" class="Symbol">=</a> <a id="3685" class="Symbol">⦇</a>
    <a id="3691" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">add⇒</a> <a id="3696" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3706" class="Symbol">(</a><a id="3707" class="Keyword">quote</a> <a id="3713" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1506" class="Field Operator">_+_</a>  <a id="3718" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3721" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3723" class="Symbol">)</a>
    <a id="3729" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">mul⇒</a> <a id="3734" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3744" class="Symbol">(</a><a id="3745" class="Keyword">quote</a> <a id="3751" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1548" class="Field Operator">_*_</a>  <a id="3756" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3759" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3761" class="Symbol">)</a>
    <a id="3767" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">pow⇒</a> <a id="3772" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3782" class="Symbol">(</a><a id="3783" class="Keyword">quote</a> <a id="3789" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2447" class="Function Operator">_^_</a>  <a id="3794" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3797" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3799" class="Symbol">)</a>
    <a id="3805" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">neg⇒</a> <a id="3810" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3820" class="Symbol">(</a><a id="3821" class="Keyword">quote</a> <a id="3827" class="Symbol">(</a><a id="3828" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1590" class="Field Operator">-_</a><a id="3830" class="Symbol">)</a> <a id="3832" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3835" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3837" class="Symbol">)</a>
    <a id="3843" href="Tactic.RingSolver.html#2649" class="InductiveConstructor Operator">sub⇒</a> <a id="3848" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="3858" class="Symbol">(</a><a id="3859" class="Keyword">quote</a> <a id="3865" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2530" class="Function Operator">_-_</a>  <a id="3870" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="3873" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="3875" class="Symbol">)</a>
    <a id="3881" class="Symbol">⦈</a>

<a id="3884" class="Comment">------------------------------------------------------------------------</a>
<a id="3957" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3998" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="4005" href="Tactic.RingSolver.html#4005" class="Module">RingSolverReflection</a> <a id="4026" class="Symbol">(</a><a id="4027" href="Tactic.RingSolver.html#4027" class="Bound">ring</a> <a id="4032" class="Symbol">:</a> <a id="4034" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="4038" class="Symbol">)</a> <a id="4040" class="Symbol">(</a><a id="4041" href="Tactic.RingSolver.html#4041" class="Bound">numberOfVariables</a> <a id="4059" class="Symbol">:</a> <a id="4061" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a><a id="4062" class="Symbol">)</a> <a id="4064" class="Keyword">where</a>
  <a id="4072" class="Keyword">open</a> <a id="4077" href="Tactic.RingSolver.html#2809" class="Module">RingReflection</a> <a id="4092" href="Tactic.RingSolver.html#4027" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4100" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4119" class="Symbol">:</a> <a id="4121" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4128" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4147" class="Symbol">=</a> <a id="4149" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="4156" href="Tactic.RingSolver.html#4041" class="Bound">numberOfVariables</a>

  <a id="4177" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4247" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4320" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4389" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4458" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4522" class="Keyword">infix</a> <a id="4528" class="Number">-1</a> <a id="4531" href="Tactic.RingSolver.html#4538" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4538" href="Tactic.RingSolver.html#4538" class="Function Operator">_$ᵉ_</a> <a id="4543" class="Symbol">:</a> <a id="4545" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="4550" class="Symbol">→</a> <a id="4552" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="4557" class="Symbol">(</a><a id="4558" href="Agda.Builtin.Reflection.html#3679" class="Datatype">Arg</a> <a id="4562" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a><a id="4566" class="Symbol">)</a> <a id="4568" class="Symbol">→</a> <a id="4570" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4577" href="Tactic.RingSolver.html#4577" class="Bound">e</a> <a id="4579" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="4582" href="Tactic.RingSolver.html#4582" class="Bound">xs</a> <a id="4585" class="Symbol">=</a> <a id="4587" href="Agda.Builtin.Reflection.html#4871" class="InductiveConstructor">con</a> <a id="4591" href="Tactic.RingSolver.html#4577" class="Bound">e</a> <a id="4593" class="Symbol">(</a><a id="4594" class="Number">1</a> <a id="4596" href="Reflection.AST.Term.html#3166" class="Function Operator">⋯⟅∷⟆</a> <a id="4601" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="4610" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4614" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4633" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4637" href="Tactic.RingSolver.html#4582" class="Bound">xs</a><a id="4639" class="Symbol">)</a>

  <a id="4644" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4672" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="4675" class="Symbol">:</a> <a id="4677" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4682" class="Symbol">→</a> <a id="4684" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4691" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="4694" href="Tactic.RingSolver.html#4694" class="Bound">x</a> <a id="4696" class="Symbol">=</a> <a id="4698" class="Keyword">quote</a> <a id="4704" href="Tactic.RingSolver.Core.Expression.html#547" class="InductiveConstructor">Κ</a> <a id="4706" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="4709" class="Symbol">(</a><a id="4710" href="Tactic.RingSolver.html#4694" class="Bound">x</a> <a id="4712" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4716" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4718" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4723" href="Tactic.RingSolver.html#4723" class="Function">`I</a> <a id="4726" class="Symbol">:</a> <a id="4728" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4733" class="Symbol">→</a> <a id="4735" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4742" href="Tactic.RingSolver.html#4723" class="Function">`I</a> <a id="4745" href="Tactic.RingSolver.html#4745" class="Bound">x</a> <a id="4747" class="Symbol">=</a> <a id="4749" class="Keyword">quote</a> <a id="4755" href="Tactic.RingSolver.Core.Expression.html#598" class="InductiveConstructor">Ι</a> <a id="4757" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="4760" class="Symbol">(</a><a id="4761" href="Tactic.RingSolver.html#4745" class="Bound">x</a> <a id="4763" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4767" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4769" class="Symbol">)</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4774" href="Tactic.RingSolver.html#4774" class="Function Operator">_`⊜_</a> <a id="4779" class="Symbol">:</a> <a id="4781" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4786" class="Symbol">→</a> <a id="4788" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4793" class="Symbol">→</a> <a id="4795" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4802" href="Tactic.RingSolver.html#4802" class="Bound">x</a> <a id="4804" href="Tactic.RingSolver.html#4774" class="Function Operator">`⊜</a> <a id="4807" href="Tactic.RingSolver.html#4807" class="Bound">y</a> <a id="4809" class="Symbol">=</a> <a id="4811" class="Keyword">quote</a> <a id="4817" href="Tactic.RingSolver.NonReflective.html#3387" class="Function Operator">_⊜_</a>  <a id="4822" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="4825" class="Symbol">(</a><a id="4826" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="4845" href="Reflection.AST.Argument.html#1817" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4849" href="Tactic.RingSolver.html#4802" class="Bound">x</a> <a id="4851" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4855" href="Tactic.RingSolver.html#4807" class="Bound">y</a> <a id="4857" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4861" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4863" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4868" href="Tactic.RingSolver.html#4868" class="Function">`correct</a> <a id="4877" class="Symbol">:</a> <a id="4879" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4884" class="Symbol">→</a> <a id="4886" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4891" class="Symbol">→</a> <a id="4893" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4900" href="Tactic.RingSolver.html#4868" class="Function">`correct</a> <a id="4909" href="Tactic.RingSolver.html#4909" class="Bound">x</a> <a id="4911" href="Tactic.RingSolver.html#4911" class="Bound">ρ</a> <a id="4913" class="Symbol">=</a> <a id="4915" class="Keyword">quote</a> <a id="4921" href="Tactic.RingSolver.NonReflective.html#2361" class="Function">Ops.correct</a> <a id="4933" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="4936" class="Symbol">(</a><a id="4937" class="Number">1</a> <a id="4939" href="Reflection.AST.Term.html#3166" class="Function Operator">⋯⟅∷⟆</a> <a id="4944" href="Tactic.RingSolver.html#4909" class="Bound">x</a> <a id="4946" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4950" href="Tactic.RingSolver.html#4911" class="Bound">ρ</a> <a id="4952" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4956" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="4958" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4963" href="Tactic.RingSolver.html#4963" class="Function">`solver</a> <a id="4971" class="Symbol">:</a> <a id="4973" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4978" class="Symbol">→</a> <a id="4980" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="4985" class="Symbol">→</a> <a id="4987" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="4994" href="Tactic.RingSolver.html#4963" class="Function">`solver</a> <a id="5002" href="Tactic.RingSolver.html#5002" class="Bound">`f</a> <a id="5005" href="Tactic.RingSolver.html#5005" class="Bound">`eq</a> <a id="5009" class="Symbol">=</a> <a id="5011" class="Keyword">quote</a> <a id="5017" href="Tactic.RingSolver.html#1384" class="Function">solver</a> <a id="5024" href="Tactic.RingSolver.html#3080" class="Function Operator">$ʳ</a> <a id="5027" class="Symbol">(</a><a id="5028" href="Tactic.RingSolver.html#4100" class="Function">`numberOfVariables</a> <a id="5047" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5051" href="Tactic.RingSolver.html#5002" class="Bound">`f</a> <a id="5054" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5058" href="Tactic.RingSolver.html#5005" class="Bound">`eq</a> <a id="5062" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5066" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="5068" class="Symbol">)</a>

  <a id="5073" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5140" class="Comment">-- used internally by the solver.</a>
  <a id="5176" class="Comment">--</a>
  <a id="5181" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5247" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5310" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5376" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5444" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5511" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5573" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5614" class="Comment">--</a>
  <a id="5619" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5688" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5756" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5813" href="Tactic.RingSolver.html#5813" class="Function">convertTerm</a> <a id="5825" class="Symbol">:</a> <a id="5827" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="5845" class="Symbol">→</a> <a id="5847" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a> <a id="5854" class="Symbol">→</a> <a id="5856" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="5861" class="Symbol">→</a> <a id="5863" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="5866" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="5873" href="Tactic.RingSolver.html#5813" class="Function">convertTerm</a> <a id="5885" href="Tactic.RingSolver.html#5885" class="Bound">operatorTerms</a> <a id="5899" href="Tactic.RingSolver.html#5899" class="Bound">varMap</a> <a id="5906" class="Symbol">=</a> <a id="5908" href="Tactic.RingSolver.html#5985" class="Function">convert</a>
    <a id="5920" class="Keyword">where</a>
    <a id="5930" class="Keyword">open</a> <a id="5935" href="Tactic.RingSolver.html#2605" class="Module">RingOperatorTerms</a> <a id="5953" href="Tactic.RingSolver.html#5885" class="Bound">operatorTerms</a>

    <a id="5972" class="Keyword">mutual</a>
      <a id="5985" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="5993" class="Symbol">:</a> <a id="5995" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="6000" class="Symbol">→</a> <a id="6002" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="6005" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="6016" class="Comment">-- First try and match directly against the fields</a>
      <a id="6073" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6081" class="Symbol">(</a><a id="6082" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6086" class="Symbol">(</a><a id="6087" class="Keyword">quote</a> <a id="6093" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1506" class="Field Operator">_+_</a><a id="6096" class="Symbol">)</a> <a id="6098" href="Tactic.RingSolver.html#6098" class="Bound">xs</a><a id="6100" class="Symbol">)</a> <a id="6102" class="Symbol">=</a> <a id="6104" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="6115" class="Symbol">(</a><a id="6116" class="Keyword">quote</a> <a id="6122" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a><a id="6125" class="Symbol">)</a> <a id="6127" href="Tactic.RingSolver.html#6098" class="Bound">xs</a>
      <a id="6136" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6144" class="Symbol">(</a><a id="6145" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6149" class="Symbol">(</a><a id="6150" class="Keyword">quote</a> <a id="6156" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1548" class="Field Operator">_*_</a><a id="6159" class="Symbol">)</a> <a id="6161" href="Tactic.RingSolver.html#6161" class="Bound">xs</a><a id="6163" class="Symbol">)</a> <a id="6165" class="Symbol">=</a> <a id="6167" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="6178" class="Symbol">(</a><a id="6179" class="Keyword">quote</a> <a id="6185" href="Tactic.RingSolver.Core.Expression.html#700" class="InductiveConstructor Operator">_⊗_</a><a id="6188" class="Symbol">)</a> <a id="6190" href="Tactic.RingSolver.html#6161" class="Bound">xs</a>
      <a id="6199" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6207" class="Symbol">(</a><a id="6208" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6212" class="Symbol">(</a><a id="6213" class="Keyword">quote</a>  <a id="6220" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1590" class="Field Operator">-_</a><a id="6222" class="Symbol">)</a> <a id="6224" href="Tactic.RingSolver.html#6224" class="Bound">xs</a><a id="6226" class="Symbol">)</a> <a id="6228" class="Symbol">=</a> <a id="6230" href="Tactic.RingSolver.html#7355" class="Function">convertOp₁</a> <a id="6241" class="Symbol">(</a><a id="6242" class="Keyword">quote</a>  <a id="6249" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a><a id="6251" class="Symbol">)</a> <a id="6253" href="Tactic.RingSolver.html#6224" class="Bound">xs</a>
      <a id="6262" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6270" class="Symbol">(</a><a id="6271" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6275" class="Symbol">(</a><a id="6276" class="Keyword">quote</a> <a id="6282" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2447" class="Function Operator">_^_</a><a id="6285" class="Symbol">)</a> <a id="6287" href="Tactic.RingSolver.html#6287" class="Bound">xs</a><a id="6289" class="Symbol">)</a> <a id="6291" class="Symbol">=</a> <a id="6293" href="Tactic.RingSolver.html#7590" class="Function">convertExp</a> <a id="6304" href="Tactic.RingSolver.html#6287" class="Bound">xs</a>
      <a id="6313" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6321" class="Symbol">(</a><a id="6322" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6326" class="Symbol">(</a><a id="6327" class="Keyword">quote</a> <a id="6333" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2530" class="Function Operator">_-_</a><a id="6336" class="Symbol">)</a> <a id="6338" href="Tactic.RingSolver.html#6338" class="Bound">xs</a><a id="6340" class="Symbol">)</a> <a id="6342" class="Symbol">=</a> <a id="6344" href="Tactic.RingSolver.html#7837" class="Function">convertSub</a> <a id="6355" href="Tactic.RingSolver.html#6338" class="Bound">xs</a>
      <a id="6364" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6442" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6450" class="Symbol">(</a><a id="6451" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="6455" href="Tactic.RingSolver.html#6455" class="Bound">nm</a>          <a id="6467" href="Tactic.RingSolver.html#6467" class="Bound">xs</a><a id="6469" class="Symbol">)</a> <a id="6471" class="Symbol">=</a> <a id="6473" href="Tactic.RingSolver.html#8134" class="Function">convertUnknownName</a> <a id="6492" href="Tactic.RingSolver.html#6455" class="Bound">nm</a> <a id="6495" href="Tactic.RingSolver.html#6467" class="Bound">xs</a>
      <a id="6504" class="Comment">-- Variables</a>
      <a id="6523" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6531" href="Tactic.RingSolver.html#6531" class="Bound">v</a><a id="6532" class="Symbol">@(</a><a id="6534" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="6538" href="Tactic.RingSolver.html#6538" class="Bound">x</a> <a id="6540" class="Symbol">_)</a>          <a id="6552" class="Symbol">=</a> <a id="6554" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="6559" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="6561" href="Data.Maybe.Base.html#1661" class="Function">fromMaybe</a> <a id="6571" class="Symbol">(</a><a id="6572" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="6575" href="Tactic.RingSolver.html#6531" class="Bound">v</a><a id="6576" class="Symbol">)</a> <a id="6578" class="Symbol">(</a><a id="6579" href="Tactic.RingSolver.html#5899" class="Bound">varMap</a> <a id="6586" href="Tactic.RingSolver.html#6538" class="Bound">x</a><a id="6587" class="Symbol">)</a>
      <a id="6595" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6649" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="6657" class="Symbol">(</a><a id="6658" href="Data.Nat.Reflection.html#616" class="InductiveConstructor">`suc</a> <a id="6663" href="Tactic.RingSolver.html#6663" class="Bound">x</a><a id="6664" class="Symbol">)</a>             <a id="6678" class="Symbol">=</a> <a id="6680" href="Tactic.RingSolver.html#8655" class="Function">convertSuc</a> <a id="6691" href="Tactic.RingSolver.html#6663" class="Bound">x</a>
      <a id="6699" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6757" href="Tactic.RingSolver.html#5985" class="CatchallClause Function">convert</a><a id="6764" class="CatchallClause"> </a><a id="6765" href="Tactic.RingSolver.html#6765" class="CatchallClause Bound">t</a>                    <a id="6786" class="Symbol">=</a> <a id="6788" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="6793" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="6795" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="6798" href="Tactic.RingSolver.html#6765" class="Bound">t</a>

      <a id="6807" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6876" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6946" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="7015" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7072" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="7083" class="Symbol">:</a> <a id="7085" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="7090" class="Symbol">→</a> <a id="7092" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7097" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7102" class="Symbol">→</a> <a id="7104" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7107" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7118" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="7129" href="Tactic.RingSolver.html#7129" class="Bound">nm</a> <a id="7132" class="Symbol">(</a><a id="7133" href="Tactic.RingSolver.html#7133" class="Bound">x</a> <a id="7135" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7139" href="Tactic.RingSolver.html#7139" class="Bound">y</a> <a id="7141" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7145" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7147" class="Symbol">)</a> <a id="7149" class="Symbol">=</a> <a id="7151" class="Keyword">do</a>
        <a id="7162" href="Tactic.RingSolver.html#7162" class="Bound">x&#39;</a> <a id="7165" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7167" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="7175" href="Tactic.RingSolver.html#7133" class="Bound">x</a>
        <a id="7185" href="Tactic.RingSolver.html#7185" class="Bound">y&#39;</a> <a id="7188" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7190" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="7198" href="Tactic.RingSolver.html#7139" class="Bound">y</a>
        <a id="7208" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7213" class="Symbol">(</a><a id="7214" href="Tactic.RingSolver.html#7129" class="Bound">nm</a> <a id="7217" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="7220" class="Symbol">(</a><a id="7221" href="Tactic.RingSolver.html#7162" class="Bound">x&#39;</a> <a id="7224" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7228" href="Tactic.RingSolver.html#7185" class="Bound">y&#39;</a> <a id="7231" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7235" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7237" class="Symbol">))</a>
      <a id="7246" href="Tactic.RingSolver.html#7072" class="CatchallClause Function">convertOp₂</a><a id="7256" class="CatchallClause"> </a><a id="7257" href="Tactic.RingSolver.html#7257" class="CatchallClause Bound">nm</a><a id="7259" class="CatchallClause"> </a><a id="7260" class="CatchallClause Symbol">(</a><a id="7261" href="Tactic.RingSolver.html#7261" class="CatchallClause Bound">x</a><a id="7262" class="CatchallClause"> </a><a id="7263" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7264" class="CatchallClause"> </a><a id="7265" href="Tactic.RingSolver.html#7265" class="CatchallClause Bound">xs</a><a id="7267" class="CatchallClause Symbol">)</a>         <a id="7277" class="Symbol">=</a> <a id="7279" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="7290" href="Tactic.RingSolver.html#7257" class="Bound">nm</a> <a id="7293" href="Tactic.RingSolver.html#7265" class="Bound">xs</a>
      <a id="7302" href="Tactic.RingSolver.html#7072" class="CatchallClause Function">convertOp₂</a><a id="7312" class="CatchallClause"> </a><a id="7313" class="CatchallClause Symbol">_</a><a id="7314" class="CatchallClause">  </a><a id="7316" class="CatchallClause Symbol">_</a>                <a id="7333" class="Symbol">=</a> <a id="7335" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7340" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="7355" href="Tactic.RingSolver.html#7355" class="Function">convertOp₁</a> <a id="7366" class="Symbol">:</a> <a id="7368" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="7373" class="Symbol">→</a> <a id="7375" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7380" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7385" class="Symbol">→</a> <a id="7387" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7390" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7401" href="Tactic.RingSolver.html#7355" class="Function">convertOp₁</a> <a id="7412" href="Tactic.RingSolver.html#7412" class="Bound">nm</a> <a id="7415" class="Symbol">(</a><a id="7416" href="Tactic.RingSolver.html#7416" class="Bound">x</a> <a id="7418" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7422" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7424" class="Symbol">)</a> <a id="7426" class="Symbol">=</a> <a id="7428" class="Keyword">do</a>
        <a id="7439" href="Tactic.RingSolver.html#7439" class="Bound">x&#39;</a> <a id="7442" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7444" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="7452" href="Tactic.RingSolver.html#7416" class="Bound">x</a>
        <a id="7462" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7467" class="Symbol">(</a><a id="7468" href="Tactic.RingSolver.html#7412" class="Bound">nm</a> <a id="7471" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="7474" class="Symbol">(</a><a id="7475" href="Tactic.RingSolver.html#7439" class="Bound">x&#39;</a> <a id="7478" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7482" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7484" class="Symbol">))</a>
      <a id="7493" href="Tactic.RingSolver.html#7355" class="CatchallClause Function">convertOp₁</a><a id="7503" class="CatchallClause"> </a><a id="7504" href="Tactic.RingSolver.html#7504" class="CatchallClause Bound">nm</a><a id="7506" class="CatchallClause"> </a><a id="7507" class="CatchallClause Symbol">(</a><a id="7508" href="Tactic.RingSolver.html#7508" class="CatchallClause Bound">x</a><a id="7509" class="CatchallClause"> </a><a id="7510" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7511" class="CatchallClause"> </a><a id="7512" href="Tactic.RingSolver.html#7512" class="CatchallClause Bound">xs</a><a id="7514" class="CatchallClause Symbol">)</a>   <a id="7518" class="Symbol">=</a> <a id="7520" href="Tactic.RingSolver.html#7355" class="Function">convertOp₁</a> <a id="7531" href="Tactic.RingSolver.html#7504" class="Bound">nm</a> <a id="7534" href="Tactic.RingSolver.html#7512" class="Bound">xs</a>
      <a id="7543" href="Tactic.RingSolver.html#7355" class="CatchallClause Function">convertOp₁</a><a id="7553" class="CatchallClause"> </a><a id="7554" class="CatchallClause Symbol">_</a><a id="7555" class="CatchallClause">  </a><a id="7557" class="CatchallClause Symbol">_</a>          <a id="7568" class="Symbol">=</a> <a id="7570" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7575" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="7590" href="Tactic.RingSolver.html#7590" class="Function">convertExp</a> <a id="7601" class="Symbol">:</a> <a id="7603" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7608" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7613" class="Symbol">→</a> <a id="7615" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7618" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7629" href="Tactic.RingSolver.html#7590" class="Function">convertExp</a> <a id="7640" class="Symbol">(</a><a id="7641" href="Tactic.RingSolver.html#7641" class="Bound">x</a> <a id="7643" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7647" href="Tactic.RingSolver.html#7647" class="Bound">y</a> <a id="7649" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7653" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7655" class="Symbol">)</a> <a id="7657" class="Symbol">=</a> <a id="7659" class="Keyword">do</a>
        <a id="7670" href="Tactic.RingSolver.html#7670" class="Bound">x&#39;</a> <a id="7673" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7675" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="7683" href="Tactic.RingSolver.html#7641" class="Bound">x</a>
        <a id="7693" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7698" class="Symbol">(</a><a id="7699" class="Keyword">quote</a> <a id="7705" href="Tactic.RingSolver.Core.Expression.html#757" class="InductiveConstructor Operator">_⊛_</a> <a id="7709" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="7712" class="Symbol">(</a><a id="7713" href="Tactic.RingSolver.html#7670" class="Bound">x&#39;</a> <a id="7716" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7720" href="Tactic.RingSolver.html#7647" class="Bound">y</a> <a id="7722" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7726" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7728" class="Symbol">))</a>
      <a id="7737" href="Tactic.RingSolver.html#7590" class="CatchallClause Function">convertExp</a><a id="7747" class="CatchallClause"> </a><a id="7748" class="CatchallClause Symbol">(</a><a id="7749" href="Tactic.RingSolver.html#7749" class="CatchallClause Bound">x</a><a id="7750" class="CatchallClause"> </a><a id="7751" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7752" class="CatchallClause"> </a><a id="7753" href="Tactic.RingSolver.html#7753" class="CatchallClause Bound">xs</a><a id="7755" class="CatchallClause Symbol">)</a>         <a id="7765" class="Symbol">=</a> <a id="7767" href="Tactic.RingSolver.html#7590" class="Function">convertExp</a> <a id="7778" href="Tactic.RingSolver.html#7753" class="Bound">xs</a>
      <a id="7787" href="Tactic.RingSolver.html#7590" class="CatchallClause Function">convertExp</a><a id="7797" class="CatchallClause"> </a><a id="7798" class="CatchallClause Symbol">_</a>                <a id="7815" class="Symbol">=</a> <a id="7817" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7822" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="7837" href="Tactic.RingSolver.html#7837" class="Function">convertSub</a> <a id="7848" class="Symbol">:</a> <a id="7850" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="7855" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="7860" class="Symbol">→</a> <a id="7862" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="7865" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="7876" href="Tactic.RingSolver.html#7837" class="Function">convertSub</a> <a id="7887" class="Symbol">(</a><a id="7888" href="Tactic.RingSolver.html#7888" class="Bound">x</a> <a id="7890" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7894" href="Tactic.RingSolver.html#7894" class="Bound">y</a> <a id="7896" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7900" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7902" class="Symbol">)</a> <a id="7904" class="Symbol">=</a> <a id="7906" class="Keyword">do</a>
        <a id="7917" href="Tactic.RingSolver.html#7917" class="Bound">x&#39;</a>  <a id="7921" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7923" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="7931" href="Tactic.RingSolver.html#7888" class="Bound">x</a>
        <a id="7941" href="Tactic.RingSolver.html#7941" class="Bound">-y&#39;</a> <a id="7945" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="7947" href="Tactic.RingSolver.html#7355" class="Function">convertOp₁</a> <a id="7958" class="Symbol">(</a><a id="7959" class="Keyword">quote</a> <a id="7965" class="Symbol">(</a><a id="7966" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a><a id="7968" class="Symbol">))</a> <a id="7971" class="Symbol">(</a><a id="7972" href="Tactic.RingSolver.html#7894" class="Bound">y</a> <a id="7974" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7978" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="7980" class="Symbol">)</a>
        <a id="7990" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="7995" class="Symbol">(</a><a id="7996" class="Keyword">quote</a> <a id="8002" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="8006" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="8009" href="Tactic.RingSolver.html#7917" class="Bound">x&#39;</a> <a id="8012" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8016" href="Tactic.RingSolver.html#7941" class="Bound">-y&#39;</a> <a id="8020" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8024" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8026" class="Symbol">)</a>
      <a id="8034" href="Tactic.RingSolver.html#7837" class="CatchallClause Function">convertSub</a><a id="8044" class="CatchallClause"> </a><a id="8045" class="CatchallClause Symbol">(</a><a id="8046" href="Tactic.RingSolver.html#8046" class="CatchallClause Bound">x</a><a id="8047" class="CatchallClause"> </a><a id="8048" href="Agda.Builtin.List.html#182" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8049" class="CatchallClause"> </a><a id="8050" href="Tactic.RingSolver.html#8050" class="CatchallClause Bound">xs</a><a id="8052" class="CatchallClause Symbol">)</a>         <a id="8062" class="Symbol">=</a> <a id="8064" href="Tactic.RingSolver.html#7837" class="Function">convertSub</a> <a id="8075" href="Tactic.RingSolver.html#8050" class="Bound">xs</a>
      <a id="8084" href="Tactic.RingSolver.html#7837" class="CatchallClause Function">convertSub</a><a id="8094" class="CatchallClause"> </a><a id="8095" class="CatchallClause Symbol">_</a>                <a id="8112" class="Symbol">=</a> <a id="8114" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="8119" href="Agda.Builtin.Reflection.html#5271" class="InductiveConstructor">unknown</a>

      <a id="8134" href="Tactic.RingSolver.html#8134" class="Function">convertUnknownName</a> <a id="8153" class="Symbol">:</a> <a id="8155" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="8160" class="Symbol">→</a> <a id="8162" href="Reflection.AST.Argument.html#1604" class="Function">Args</a> <a id="8167" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8172" class="Symbol">→</a> <a id="8174" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="8177" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="8188" href="Tactic.RingSolver.html#8134" class="Function">convertUnknownName</a> <a id="8207" href="Tactic.RingSolver.html#8207" class="Bound">nm</a> <a id="8210" href="Tactic.RingSolver.html#8210" class="Bound">xs</a> <a id="8213" class="Symbol">=</a> <a id="8215" class="Keyword">do</a>
        <a id="8226" href="Tactic.RingSolver.html#8226" class="Bound">nameTerm</a> <a id="8235" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="8237" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a> <a id="8247" class="Symbol">(</a><a id="8248" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8252" href="Tactic.RingSolver.html#8207" class="Bound">nm</a> <a id="8255" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8257" class="Symbol">)</a>
        <a id="8267" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8270" class="Symbol">(</a><a id="8271" href="Tactic.RingSolver.html#8226" class="Bound">nameTerm</a> <a id="8280" href="Reflection.AST.AlphaEquality.html#1403" class="Field Operator">=α=</a> <a id="8284" href="Tactic.RingSolver.html#2687" class="Function">add</a><a id="8287" class="Symbol">)</a> <a id="8289" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8294" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="8305" class="Symbol">(</a><a id="8306" class="Keyword">quote</a> <a id="8312" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a><a id="8315" class="Symbol">)</a> <a id="8317" href="Tactic.RingSolver.html#8210" class="Bound">xs</a> <a id="8320" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
          <a id="8335" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8338" class="Symbol">(</a><a id="8339" href="Tactic.RingSolver.html#8226" class="Bound">nameTerm</a> <a id="8348" href="Reflection.AST.AlphaEquality.html#1403" class="Field Operator">=α=</a> <a id="8352" href="Tactic.RingSolver.html#2691" class="Function">mul</a><a id="8355" class="Symbol">)</a> <a id="8357" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8362" href="Tactic.RingSolver.html#7072" class="Function">convertOp₂</a> <a id="8373" class="Symbol">(</a><a id="8374" class="Keyword">quote</a> <a id="8380" href="Tactic.RingSolver.Core.Expression.html#700" class="InductiveConstructor Operator">_⊗_</a><a id="8383" class="Symbol">)</a> <a id="8385" href="Tactic.RingSolver.html#8210" class="Bound">xs</a> <a id="8388" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
            <a id="8405" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8408" class="Symbol">(</a><a id="8409" href="Tactic.RingSolver.html#8226" class="Bound">nameTerm</a> <a id="8418" href="Reflection.AST.AlphaEquality.html#1403" class="Field Operator">=α=</a> <a id="8422" href="Tactic.RingSolver.html#2699" class="Function">neg</a><a id="8425" class="Symbol">)</a> <a id="8427" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8432" href="Tactic.RingSolver.html#7355" class="Function">convertOp₁</a> <a id="8443" class="Symbol">(</a><a id="8444" class="Keyword">quote</a> <a id="8450" href="Tactic.RingSolver.Core.Expression.html#814" class="InductiveConstructor Operator">⊝_</a><a id="8452" class="Symbol">)</a>  <a id="8455" href="Tactic.RingSolver.html#8210" class="Bound">xs</a> <a id="8458" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
              <a id="8477" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8480" class="Symbol">(</a><a id="8481" href="Tactic.RingSolver.html#8226" class="Bound">nameTerm</a> <a id="8490" href="Reflection.AST.AlphaEquality.html#1403" class="Field Operator">=α=</a> <a id="8494" href="Tactic.RingSolver.html#2695" class="Function">pow</a><a id="8497" class="Symbol">)</a> <a id="8499" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8504" href="Tactic.RingSolver.html#7590" class="Function">convertExp</a>             <a id="8527" href="Tactic.RingSolver.html#8210" class="Bound">xs</a> <a id="8530" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                <a id="8551" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="8554" class="Symbol">(</a><a id="8555" href="Tactic.RingSolver.html#8226" class="Bound">nameTerm</a> <a id="8564" href="Reflection.AST.AlphaEquality.html#1403" class="Field Operator">=α=</a> <a id="8568" href="Tactic.RingSolver.html#2703" class="Function">sub</a><a id="8571" class="Symbol">)</a> <a id="8573" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="8578" href="Tactic.RingSolver.html#7837" class="Function">convertSub</a>            <a id="8600" href="Tactic.RingSolver.html#8210" class="Bound">xs</a> <a id="8603" href="Data.Bool.Base.html#1292" class="Function Operator">else</a>
                  <a id="8626" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="8631" class="Symbol">(</a><a id="8632" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="8635" class="Symbol">(</a><a id="8636" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="8640" href="Tactic.RingSolver.html#8207" class="Bound">nm</a> <a id="8643" href="Tactic.RingSolver.html#8210" class="Bound">xs</a><a id="8645" class="Symbol">))</a>

      <a id="8655" href="Tactic.RingSolver.html#8655" class="Function">convertSuc</a> <a id="8666" class="Symbol">:</a> <a id="8668" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="8673" class="Symbol">→</a> <a id="8675" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="8678" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
      <a id="8689" href="Tactic.RingSolver.html#8655" class="Function">convertSuc</a> <a id="8700" href="Tactic.RingSolver.html#8700" class="Bound">x</a> <a id="8702" class="Symbol">=</a> <a id="8704" class="Keyword">do</a> <a id="8707" href="Tactic.RingSolver.html#8707" class="Bound">x&#39;</a> <a id="8710" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="8712" href="Tactic.RingSolver.html#5985" class="Function">convert</a> <a id="8720" href="Tactic.RingSolver.html#8700" class="Bound">x</a><a id="8721" class="Symbol">;</a> <a id="8723" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="8728" class="Symbol">(</a><a id="8729" class="Keyword">quote</a> <a id="8735" href="Tactic.RingSolver.Core.Expression.html#649" class="InductiveConstructor Operator">_⊕_</a> <a id="8739" href="Tactic.RingSolver.html#4538" class="Function Operator">$ᵉ</a> <a id="8742" class="Symbol">(</a><a id="8743" href="Tactic.RingSolver.html#4672" class="Function">`Κ</a> <a id="8746" class="Symbol">(</a><a id="8747" href="Data.Nat.Reflection.html#653" class="Function">toTerm</a> <a id="8754" class="Number">1</a><a id="8755" class="Symbol">)</a> <a id="8757" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8761" href="Tactic.RingSolver.html#8707" class="Bound">x&#39;</a> <a id="8764" href="Reflection.AST.Argument.html#1721" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8768" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="8770" class="Symbol">))</a>

<a id="8774" class="Comment">------------------------------------------------------------------------</a>
<a id="8847" class="Comment">-- Macros</a>
<a id="8857" class="Comment">------------------------------------------------------------------------</a>
<a id="8930" class="Comment">-- Quantified macro</a>

<a id="8951" class="Keyword">open</a> <a id="8956" href="Tactic.RingSolver.html#2809" class="Module">RingReflection</a>
<a id="8971" class="Keyword">open</a> <a id="8976" href="Tactic.RingSolver.html#4005" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="8998" href="Tactic.RingSolver.html#8998" class="Function">malformedForallTypeError</a> <a id="9023" class="Symbol">:</a> <a id="9025" class="Symbol">∀</a> <a id="9027" class="Symbol">{</a><a id="9028" href="Tactic.RingSolver.html#9028" class="Bound">a</a><a id="9029" class="Symbol">}</a> <a id="9031" class="Symbol">{</a><a id="9032" href="Tactic.RingSolver.html#9032" class="Bound">A</a> <a id="9034" class="Symbol">:</a> <a id="9036" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="9040" href="Tactic.RingSolver.html#9028" class="Bound">a</a><a id="9041" class="Symbol">}</a> <a id="9043" class="Symbol">→</a> <a id="9045" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9050" class="Symbol">→</a> <a id="9052" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9055" href="Tactic.RingSolver.html#9032" class="Bound">A</a>
<a id="9057" href="Tactic.RingSolver.html#8998" class="Function">malformedForallTypeError</a> <a id="9082" href="Tactic.RingSolver.html#9082" class="Bound">found</a> <a id="9088" class="Symbol">=</a> <a id="9090" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a>
  <a id="9102" class="Symbol">(</a> <a id="9104" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="9111" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9140" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9142" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="9149" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9209" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9211" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="9218" class="String">&quot;Instead: &quot;</a>
  <a id="9232" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9234" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="9242" href="Tactic.RingSolver.html#9082" class="Bound">found</a>
  <a id="9250" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="9252" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9254" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9257" href="Tactic.RingSolver.html#9257" class="Function">quantifiedVarMap</a> <a id="9274" class="Symbol">:</a> <a id="9276" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a> <a id="9278" class="Symbol">→</a> <a id="9280" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a>
<a id="9287" href="Tactic.RingSolver.html#9257" class="Function">quantifiedVarMap</a> <a id="9304" href="Tactic.RingSolver.html#9304" class="Bound">numVars</a> <a id="9312" href="Tactic.RingSolver.html#9312" class="Bound">i</a> <a id="9314" class="Symbol">=</a>
  <a id="9318" href="Data.Bool.Base.html#1292" class="Function Operator">if</a> <a id="9321" href="Tactic.RingSolver.html#9312" class="Bound">i</a> <a id="9323" href="Data.Nat.Base.html#1310" class="Primitive Operator">&lt;ᵇ</a> <a id="9326" href="Tactic.RingSolver.html#9304" class="Bound">numVars</a>
    <a id="9338" href="Data.Bool.Base.html#1292" class="Function Operator">then</a> <a id="9343" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="9348" class="Symbol">(</a><a id="9349" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="9353" href="Tactic.RingSolver.html#9312" class="Bound">i</a> <a id="9355" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="9357" class="Symbol">)</a>
    <a id="9363" href="Data.Bool.Base.html#1292" class="Function Operator">else</a> <a id="9368" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9377" href="Tactic.RingSolver.html#9377" class="Function">constructCallToSolver</a> <a id="9399" class="Symbol">:</a> <a id="9401" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9406" class="Symbol">→</a> <a id="9408" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="9426" class="Symbol">→</a> <a id="9428" href="Agda.Builtin.List.html#130" class="Datatype">List</a> <a id="9433" href="Agda.Builtin.String.html#318" class="Postulate">String</a> <a id="9440" class="Symbol">→</a> <a id="9442" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9447" class="Symbol">→</a> <a id="9449" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9454" class="Symbol">→</a> <a id="9456" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9459" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="9464" href="Tactic.RingSolver.html#9377" class="Function">constructCallToSolver</a> <a id="9486" href="Tactic.RingSolver.html#9486" class="Bound">`ring</a> <a id="9492" href="Tactic.RingSolver.html#9492" class="Bound">opNames</a> <a id="9500" href="Tactic.RingSolver.html#9500" class="Bound">variables</a> <a id="9510" href="Tactic.RingSolver.html#9510" class="Bound">`lhs</a> <a id="9515" href="Tactic.RingSolver.html#9515" class="Bound">`rhs</a> <a id="9520" class="Symbol">=</a> <a id="9522" class="Keyword">do</a>
  <a id="9527" href="Tactic.RingSolver.html#9527" class="Bound">`lhsExpr</a> <a id="9536" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9538" href="Tactic.RingSolver.html#9805" class="Function">conv</a> <a id="9543" href="Tactic.RingSolver.html#9510" class="Bound">`lhs</a>
  <a id="9550" href="Tactic.RingSolver.html#9550" class="Bound">`rhsExpr</a> <a id="9559" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="9561" href="Tactic.RingSolver.html#9805" class="Function">conv</a> <a id="9566" href="Tactic.RingSolver.html#9515" class="Bound">`rhs</a>

  <a id="9574" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="9579" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="9581" href="Tactic.RingSolver.html#4963" class="Function">`solver</a> <a id="9589" href="Tactic.RingSolver.html#9486" class="Bound">`ring</a> <a id="9595" href="Tactic.RingSolver.html#9756" class="Function">numVars</a>
                    <a id="9623" class="Symbol">(</a><a id="9624" href="Reflection.AST.Term.html#3828" class="Function">prependVLams</a> <a id="9637" href="Tactic.RingSolver.html#9500" class="Bound">variables</a> <a id="9647" class="Symbol">(</a><a id="9648" href="Tactic.RingSolver.html#4774" class="Function Operator">_`⊜_</a> <a id="9653" href="Tactic.RingSolver.html#9486" class="Bound">`ring</a> <a id="9659" href="Tactic.RingSolver.html#9756" class="Function">numVars</a> <a id="9667" href="Tactic.RingSolver.html#9527" class="Bound">`lhsExpr</a> <a id="9676" href="Tactic.RingSolver.html#9550" class="Bound">`rhsExpr</a><a id="9684" class="Symbol">))</a>
                    <a id="9707" class="Symbol">(</a><a id="9708" href="Reflection.AST.Term.html#3730" class="Function">prependHLams</a> <a id="9721" href="Tactic.RingSolver.html#9500" class="Bound">variables</a> <a id="9731" class="Symbol">(</a><a id="9732" href="Tactic.RingSolver.html#3212" class="Function">`refl</a> <a id="9738" href="Tactic.RingSolver.html#9486" class="Bound">`ring</a><a id="9743" class="Symbol">))</a>
  <a id="9748" class="Keyword">where</a>
  <a id="9756" href="Tactic.RingSolver.html#9756" class="Function">numVars</a> <a id="9764" class="Symbol">:</a> <a id="9766" href="Agda.Builtin.Nat.html#186" class="Datatype">ℕ</a>
  <a id="9770" href="Tactic.RingSolver.html#9756" class="Function">numVars</a> <a id="9778" class="Symbol">=</a> <a id="9780" href="Data.List.Base.html#5072" class="Function">List.length</a> <a id="9792" href="Tactic.RingSolver.html#9500" class="Bound">variables</a>

  <a id="9805" href="Tactic.RingSolver.html#9805" class="Function">conv</a> <a id="9810" class="Symbol">:</a> <a id="9812" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="9817" class="Symbol">→</a> <a id="9819" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="9822" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="9829" href="Tactic.RingSolver.html#9805" class="Function">conv</a> <a id="9834" class="Symbol">=</a> <a id="9836" href="Tactic.RingSolver.html#5813" class="Function">convertTerm</a> <a id="9848" href="Tactic.RingSolver.html#9486" class="Bound">`ring</a> <a id="9854" href="Tactic.RingSolver.html#9756" class="Function">numVars</a> <a id="9862" href="Tactic.RingSolver.html#9492" class="Bound">opNames</a> <a id="9870" class="Symbol">(</a><a id="9871" href="Tactic.RingSolver.html#9257" class="Function">quantifiedVarMap</a> <a id="9888" href="Tactic.RingSolver.html#9756" class="Function">numVars</a><a id="9895" class="Symbol">)</a>

<a id="9898" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9964" class="Comment">-- variables are universally quantified over:</a>
<a id="10010" class="Comment">--</a>
<a id="10013" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10048" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10074" class="Comment">--</a>
<a id="10077" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10140" class="Comment">-- (Find some example implementations in</a>
<a id="10181" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10241" href="Tactic.RingSolver.html#10241" class="Function">solve-∀-macro</a> <a id="10255" class="Symbol">:</a> <a id="10257" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="10262" class="Symbol">→</a> <a id="10264" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="10269" class="Symbol">→</a> <a id="10271" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="10274" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
<a id="10276" href="Tactic.RingSolver.html#10241" class="Function">solve-∀-macro</a> <a id="10290" href="Tactic.RingSolver.html#10290" class="Bound">ring</a> <a id="10295" href="Tactic.RingSolver.html#10295" class="Bound">hole</a> <a id="10300" class="Symbol">=</a> <a id="10302" class="Keyword">do</a>
  <a id="10307" href="Tactic.RingSolver.html#10307" class="Bound">`ring</a> <a id="10313" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10315" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="10327" class="Symbol">(</a><a id="10328" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="10332" href="Tactic.RingSolver.html#10290" class="Bound">ring</a> <a id="10337" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="10339" class="Symbol">)</a>
  <a id="10343" href="Agda.Builtin.Reflection.html#9504" class="Postulate">commitTC</a>
  <a id="10354" href="Tactic.RingSolver.html#10354" class="Bound">operatorTerms</a> <a id="10368" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10370" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="10391" href="Tactic.RingSolver.html#10307" class="Bound">`ring</a>

  <a id="10400" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10439" href="Tactic.RingSolver.html#10439" class="Bound">`hole</a> <a id="10445" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10447" href="Agda.Builtin.Reflection.html#8555" class="Postulate">inferType</a> <a id="10457" href="Tactic.RingSolver.html#10295" class="Bound">hole</a> <a id="10462" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="10466" href="Agda.Builtin.Reflection.html#8670" class="Postulate">reduce</a>
  <a id="10475" class="Keyword">let</a> <a id="10479" href="Tactic.RingSolver.html#10479" class="Bound">variablesAndTypes</a> <a id="10497" href="Agda.Builtin.Sigma.html#218" class="InductiveConstructor Operator">,</a> <a id="10499" href="Tactic.RingSolver.html#10499" class="Bound">equation</a> <a id="10508" class="Symbol">=</a> <a id="10510" href="Reflection.AST.Term.html#3459" class="Function">stripPis</a> <a id="10519" href="Tactic.RingSolver.html#10439" class="Bound">`hole</a>

  <a id="10528" class="Keyword">let</a> <a id="10532" href="Tactic.RingSolver.html#10532" class="Bound">variables</a> <a id="10542" class="Symbol">=</a> <a id="10544" href="Data.List.Base.html#1620" class="Function">List.map</a> <a id="10553" href="Data.Product.Base.html#636" class="Field">proj₁</a> <a id="10559" href="Tactic.RingSolver.html#10479" class="Bound">variablesAndTypes</a>
  <a id="10579" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="10584" class="Symbol">(</a><a id="10585" href="Tactic.RingSolver.html#10585" class="Bound">lhs</a> <a id="10589" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="10591" href="Tactic.RingSolver.html#10591" class="Bound">rhs</a> <a id="10595" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="10597" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a><a id="10599" class="Symbol">)</a> <a id="10601" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10603" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="10608" class="Symbol">(</a><a id="10609" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="10624" class="Number">2</a> <a id="10626" href="Tactic.RingSolver.html#10499" class="Bound">equation</a><a id="10634" class="Symbol">)</a>
    <a id="10640" class="Keyword">where</a> <a id="10646" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="10654" class="Symbol">→</a> <a id="10656" href="Tactic.RingSolver.html#8998" class="Function">malformedForallTypeError</a> <a id="10681" href="Tactic.RingSolver.html#10439" class="Bound">`hole</a>

  <a id="10690" href="Tactic.RingSolver.html#10690" class="Bound">solverCall</a> <a id="10701" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="10703" href="Tactic.RingSolver.html#9377" class="Function">constructCallToSolver</a> <a id="10725" href="Tactic.RingSolver.html#10307" class="Bound">`ring</a> <a id="10731" href="Tactic.RingSolver.html#10354" class="Bound">operatorTerms</a> <a id="10745" href="Tactic.RingSolver.html#10532" class="Bound">variables</a> <a id="10755" href="Tactic.RingSolver.html#10585" class="Bound">lhs</a> <a id="10759" href="Tactic.RingSolver.html#10591" class="Bound">rhs</a>
  <a id="10765" href="Agda.Builtin.Reflection.html#8452" class="Postulate">unify</a> <a id="10771" href="Tactic.RingSolver.html#10295" class="Bound">hole</a> <a id="10776" href="Tactic.RingSolver.html#10690" class="Bound">solverCall</a>

<a id="10788" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10796" href="Tactic.RingSolver.html#10796" class="Function">solve-∀</a> <a id="10804" class="Symbol">:</a> <a id="10806" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="10811" class="Symbol">→</a> <a id="10813" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="10818" class="Symbol">→</a> <a id="10820" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="10823" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
  <a id="10827" href="Tactic.RingSolver.html#10796" class="Function">solve-∀</a> <a id="10835" class="Symbol">=</a> <a id="10837" href="Tactic.RingSolver.html#10241" class="Function">solve-∀-macro</a>

<a id="10852" class="Comment">------------------------------------------------------------------------</a>
<a id="10925" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10948" href="Tactic.RingSolver.html#10948" class="Function">malformedArgumentListError</a> <a id="10975" class="Symbol">:</a> <a id="10977" class="Symbol">∀</a> <a id="10979" class="Symbol">{</a><a id="10980" href="Tactic.RingSolver.html#10980" class="Bound">a</a><a id="10981" class="Symbol">}</a> <a id="10983" class="Symbol">{</a><a id="10984" href="Tactic.RingSolver.html#10984" class="Bound">A</a> <a id="10986" class="Symbol">:</a> <a id="10988" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="10992" href="Tactic.RingSolver.html#10980" class="Bound">a</a><a id="10993" class="Symbol">}</a> <a id="10995" class="Symbol">→</a> <a id="10997" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11002" class="Symbol">→</a> <a id="11004" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11007" href="Tactic.RingSolver.html#10984" class="Bound">A</a>
<a id="11009" href="Tactic.RingSolver.html#10948" class="Function">malformedArgumentListError</a> <a id="11036" href="Tactic.RingSolver.html#11036" class="Bound">found</a> <a id="11042" class="Symbol">=</a> <a id="11044" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a>
  <a id="11056" class="Symbol">(</a> <a id="11058" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11065" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11094" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11096" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11103" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11158" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11160" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11167" class="String">&quot;Instead: &quot;</a>
  <a id="11181" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11183" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="11191" href="Tactic.RingSolver.html#11036" class="Bound">found</a>
  <a id="11199" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11201" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="11203" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11206" href="Tactic.RingSolver.html#11206" class="Function">malformedGoalError</a> <a id="11225" class="Symbol">:</a> <a id="11227" class="Symbol">∀</a> <a id="11229" class="Symbol">{</a><a id="11230" href="Tactic.RingSolver.html#11230" class="Bound">a</a><a id="11231" class="Symbol">}</a> <a id="11233" class="Symbol">{</a><a id="11234" href="Tactic.RingSolver.html#11234" class="Bound">A</a> <a id="11236" class="Symbol">:</a> <a id="11238" href="Agda.Primitive.html#320" class="Primitive">Set</a> <a id="11242" href="Tactic.RingSolver.html#11230" class="Bound">a</a><a id="11243" class="Symbol">}</a> <a id="11245" class="Symbol">→</a> <a id="11247" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11252" class="Symbol">→</a> <a id="11254" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11257" href="Tactic.RingSolver.html#11234" class="Bound">A</a>
<a id="11259" href="Tactic.RingSolver.html#11206" class="Function">malformedGoalError</a> <a id="11278" href="Tactic.RingSolver.html#11278" class="Bound">found</a> <a id="11284" class="Symbol">=</a> <a id="11286" href="Agda.Builtin.Reflection.html#8492" class="Postulate">typeError</a>
  <a id="11298" class="Symbol">(</a> <a id="11300" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11307" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11336" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11338" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11345" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11392" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11394" href="Agda.Builtin.Reflection.html#7900" class="InductiveConstructor">strErr</a> <a id="11401" class="String">&quot;Instead: &quot;</a>
  <a id="11415" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11417" href="Agda.Builtin.Reflection.html#7931" class="InductiveConstructor">termErr</a> <a id="11425" href="Tactic.RingSolver.html#11278" class="Bound">found</a>
  <a id="11433" href="Agda.Builtin.List.html#182" class="InductiveConstructor Operator">∷</a> <a id="11435" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="11437" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11440" href="Tactic.RingSolver.html#11440" class="Function">checkIsListOfVariables</a> <a id="11463" class="Symbol">:</a> <a id="11465" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11470" class="Symbol">→</a> <a id="11472" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11477" class="Symbol">→</a> <a id="11479" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11482" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="11487" href="Tactic.RingSolver.html#11440" class="Function">checkIsListOfVariables</a> <a id="11510" href="Tactic.RingSolver.html#11510" class="Bound">`ring</a> <a id="11516" href="Tactic.RingSolver.html#11516" class="Bound">`xs</a> <a id="11520" class="Symbol">=</a> <a id="11522" href="Agda.Builtin.Reflection.html#8591" class="Postulate">checkType</a> <a id="11532" href="Tactic.RingSolver.html#11516" class="Bound">`xs</a> <a id="11536" class="Symbol">(</a><a id="11537" href="Data.List.Reflection.html#471" class="Function">`List</a> <a id="11543" class="Symbol">(</a><a id="11544" href="Tactic.RingSolver.html#3160" class="Function">`Carrier</a> <a id="11553" href="Tactic.RingSolver.html#11510" class="Bound">`ring</a><a id="11558" class="Symbol">))</a> <a id="11561" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="11565" href="Agda.Builtin.Reflection.html#8634" class="Postulate">normalise</a>

<a id="11576" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11634" href="Tactic.RingSolver.html#11634" class="Function">getVariableIndices</a> <a id="11653" class="Symbol">:</a> <a id="11655" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11660" class="Symbol">→</a> <a id="11662" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="11668" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a>
<a id="11675" href="Tactic.RingSolver.html#11634" class="Function">getVariableIndices</a> <a id="11694" class="Symbol">=</a> <a id="11696" href="Tactic.RingSolver.html#11712" class="Function">go</a> <a id="11699" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a>
  <a id="11704" class="Keyword">where</a>
  <a id="11712" href="Tactic.RingSolver.html#11712" class="Function">go</a> <a id="11715" class="Symbol">:</a> <a id="11717" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a> <a id="11724" class="Symbol">→</a> <a id="11726" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11731" class="Symbol">→</a> <a id="11733" href="Agda.Builtin.Maybe.html#118" class="Datatype">Maybe</a> <a id="11739" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a>
  <a id="11748" href="Tactic.RingSolver.html#11712" class="Function">go</a> <a id="11751" href="Tactic.RingSolver.html#11751" class="Bound">t</a> <a id="11753" class="Symbol">(</a><a id="11754" href="Agda.Builtin.Reflection.html#4815" class="InductiveConstructor">var</a> <a id="11758" href="Tactic.RingSolver.html#11758" class="Bound">i</a> <a id="11760" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a> <a id="11763" href="Data.List.Reflection.html#980" class="InductiveConstructor Operator">`∷`</a> <a id="11767" href="Tactic.RingSolver.html#11767" class="Bound">xs</a><a id="11769" class="Symbol">)</a> <a id="11771" class="Symbol">=</a> <a id="11773" href="Tactic.RingSolver.html#11712" class="Function">go</a> <a id="11776" class="Symbol">(</a><a id="11777" href="Tactic.RingSolver.Core.NatSet.html#2292" class="Function">insert</a> <a id="11784" href="Tactic.RingSolver.html#11758" class="Bound">i</a> <a id="11786" href="Tactic.RingSolver.html#11751" class="Bound">t</a><a id="11787" class="Symbol">)</a> <a id="11789" href="Tactic.RingSolver.html#11767" class="Bound">xs</a>
  <a id="11794" href="Tactic.RingSolver.html#11712" class="Function">go</a> <a id="11797" href="Tactic.RingSolver.html#11797" class="Bound">t</a> <a id="11799" href="Data.List.Reflection.html#936" class="InductiveConstructor">`[]`</a>              <a id="11817" class="Symbol">=</a> <a id="11819" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="11824" href="Tactic.RingSolver.html#11797" class="Bound">t</a>
  <a id="11828" href="Tactic.RingSolver.html#11712" class="CatchallClause Function">go</a><a id="11830" class="CatchallClause"> </a><a id="11831" class="CatchallClause Symbol">_</a><a id="11832" class="CatchallClause"> </a><a id="11833" class="CatchallClause Symbol">_</a>                 <a id="11851" class="Symbol">=</a> <a id="11853" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11862" href="Tactic.RingSolver.html#11862" class="Function">constructSolution</a> <a id="11880" class="Symbol">:</a> <a id="11882" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11887" class="Symbol">→</a> <a id="11889" href="Tactic.RingSolver.html#2605" class="Record">RingOperatorTerms</a> <a id="11907" class="Symbol">→</a> <a id="11909" href="Tactic.RingSolver.Core.NatSet.html#2175" class="Function">NatSet</a> <a id="11916" class="Symbol">→</a> <a id="11918" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11923" class="Symbol">→</a> <a id="11925" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="11930" class="Symbol">→</a> <a id="11932" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="11935" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
<a id="11940" href="Tactic.RingSolver.html#11862" class="Function">constructSolution</a> <a id="11958" href="Tactic.RingSolver.html#11958" class="Bound">`ring</a> <a id="11964" href="Tactic.RingSolver.html#11964" class="Bound">opTerms</a> <a id="11972" href="Tactic.RingSolver.html#11972" class="Bound">variables</a> <a id="11982" href="Tactic.RingSolver.html#11982" class="Bound">`lhs</a> <a id="11987" href="Tactic.RingSolver.html#11987" class="Bound">`rhs</a> <a id="11992" class="Symbol">=</a> <a id="11994" class="Keyword">do</a>
  <a id="11999" href="Tactic.RingSolver.html#11999" class="Bound">`lhsExpr</a> <a id="12008" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12010" href="Tactic.RingSolver.html#12283" class="Function">conv</a> <a id="12015" href="Tactic.RingSolver.html#11982" class="Bound">`lhs</a>
  <a id="12022" href="Tactic.RingSolver.html#12022" class="Bound">`rhsExpr</a> <a id="12031" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12033" href="Tactic.RingSolver.html#12283" class="Function">conv</a> <a id="12038" href="Tactic.RingSolver.html#11987" class="Bound">`rhs</a>
  <a id="12045" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="12050" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="12052" href="Tactic.RingSolver.html#3332" class="Function">`trans</a> <a id="12059" href="Tactic.RingSolver.html#11958" class="Bound">`ring</a> <a id="12065" class="Symbol">(</a><a id="12066" href="Tactic.RingSolver.html#3264" class="Function">`sym</a> <a id="12071" href="Tactic.RingSolver.html#11958" class="Bound">`ring</a> <a id="12077" href="Tactic.RingSolver.html#11999" class="Bound">`lhsExpr</a><a id="12085" class="Symbol">)</a> <a id="12087" href="Tactic.RingSolver.html#12022" class="Bound">`rhsExpr</a>
  <a id="12098" class="Keyword">where</a>
  <a id="12106" href="Tactic.RingSolver.html#12106" class="Function">numVars</a> <a id="12114" class="Symbol">=</a> <a id="12116" href="Data.List.Base.html#5072" class="Function">List.length</a> <a id="12128" href="Tactic.RingSolver.html#11972" class="Bound">variables</a>

  <a id="12141" href="Tactic.RingSolver.html#12141" class="Function">varMap</a> <a id="12148" class="Symbol">:</a> <a id="12150" href="Tactic.RingSolver.html#1627" class="Function">VarMap</a>
  <a id="12159" href="Tactic.RingSolver.html#12141" class="Function">varMap</a> <a id="12166" href="Tactic.RingSolver.html#12166" class="Bound">i</a> <a id="12168" class="Symbol">=</a> <a id="12170" href="Data.Maybe.Base.html#2049" class="Function">Maybe.map</a> <a id="12180" class="Symbol">(λ</a> <a id="12183" href="Tactic.RingSolver.html#12183" class="Bound">x</a> <a id="12185" class="Symbol">→</a> <a id="12187" href="Tactic.RingSolver.html#4723" class="Function">`I</a> <a id="12190" href="Tactic.RingSolver.html#11958" class="Bound">`ring</a> <a id="12196" href="Tactic.RingSolver.html#12106" class="Function">numVars</a> <a id="12204" class="Symbol">(</a><a id="12205" href="Data.Nat.Reflection.html#728" class="Function">toFinTerm</a> <a id="12215" href="Tactic.RingSolver.html#12183" class="Bound">x</a><a id="12216" class="Symbol">))</a> <a id="12219" class="Symbol">(</a><a id="12220" href="Tactic.RingSolver.Core.NatSet.html#2940" class="Function">lookup</a> <a id="12227" href="Tactic.RingSolver.html#11972" class="Bound">variables</a> <a id="12237" href="Tactic.RingSolver.html#12166" class="Bound">i</a><a id="12238" class="Symbol">)</a>

  <a id="12243" href="Tactic.RingSolver.html#12243" class="Function">ρ</a> <a id="12245" class="Symbol">:</a> <a id="12247" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a>
  <a id="12254" href="Tactic.RingSolver.html#12243" class="Function">ρ</a> <a id="12256" class="Symbol">=</a> <a id="12258" href="Tactic.RingSolver.html#2237" class="Function">curriedTerm</a> <a id="12270" href="Tactic.RingSolver.html#11972" class="Bound">variables</a>

  <a id="12283" href="Tactic.RingSolver.html#12283" class="Function">conv</a> <a id="12288" class="Symbol">=</a> <a id="12290" class="Symbol">λ</a> <a id="12292" href="Tactic.RingSolver.html#12292" class="Bound">t</a> <a id="12294" class="Symbol">→</a> <a id="12296" class="Keyword">do</a>
    <a id="12303" href="Tactic.RingSolver.html#12303" class="Bound">t&#39;</a> <a id="12306" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="12308" href="Tactic.RingSolver.html#5813" class="Function">convertTerm</a> <a id="12320" href="Tactic.RingSolver.html#11958" class="Bound">`ring</a> <a id="12326" href="Tactic.RingSolver.html#12106" class="Function">numVars</a> <a id="12334" href="Tactic.RingSolver.html#11964" class="Bound">opTerms</a> <a id="12342" href="Tactic.RingSolver.html#12141" class="Function">varMap</a> <a id="12349" href="Tactic.RingSolver.html#12292" class="Bound">t</a>
    <a id="12355" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="12360" href="Function.Base.html#2003" class="Function Operator">$</a> <a id="12362" href="Tactic.RingSolver.html#4868" class="Function">`correct</a> <a id="12371" href="Tactic.RingSolver.html#11958" class="Bound">`ring</a> <a id="12377" href="Tactic.RingSolver.html#12106" class="Function">numVars</a> <a id="12385" href="Tactic.RingSolver.html#12303" class="Bound">t&#39;</a> <a id="12388" href="Tactic.RingSolver.html#12243" class="Function">ρ</a>

<a id="12391" class="Comment">-- Use this macro when you want to solve something *under* a lambda.</a>
<a id="12460" class="Comment">-- For example: say you have a long proof, and you just want the solver</a>
<a id="12532" class="Comment">-- to deal with an intermediate step. Call it like so:</a>
<a id="12587" class="Comment">--</a>
<a id="12590" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12642" class="Comment">--   lemma₃ x y = begin</a>
<a id="12666" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12725" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12779" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12810" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12833" class="Comment">--</a>
<a id="12836" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12903" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12939" href="Tactic.RingSolver.html#12939" class="Function">solve-macro</a> <a id="12951" class="Symbol">:</a> <a id="12953" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="12958" class="Symbol">→</a> <a id="12960" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="12965" class="Symbol">→</a> <a id="12967" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="12972" class="Symbol">→</a> <a id="12974" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="12977" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
<a id="12979" href="Tactic.RingSolver.html#12939" class="Function">solve-macro</a> <a id="12991" href="Tactic.RingSolver.html#12991" class="Bound">variables</a> <a id="13001" href="Tactic.RingSolver.html#13001" class="Bound">ring</a> <a id="13006" href="Tactic.RingSolver.html#13006" class="Bound">hole</a> <a id="13011" class="Symbol">=</a> <a id="13013" class="Keyword">do</a>
  <a id="13018" href="Tactic.RingSolver.html#13018" class="Bound">`ring</a> <a id="13024" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13026" href="Tactic.RingSolver.html#2715" class="Function">checkIsRing</a> <a id="13038" class="Symbol">(</a><a id="13039" href="Agda.Builtin.Reflection.html#4928" class="InductiveConstructor">def</a> <a id="13043" href="Tactic.RingSolver.html#13001" class="Bound">ring</a> <a id="13048" href="Agda.Builtin.List.html#167" class="InductiveConstructor">[]</a><a id="13050" class="Symbol">)</a>
  <a id="13054" href="Agda.Builtin.Reflection.html#9504" class="Postulate">commitTC</a>
  <a id="13065" href="Tactic.RingSolver.html#13065" class="Bound">operatorTerms</a> <a id="13079" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13081" href="Tactic.RingSolver.html#3616" class="Function">getRingOperatorTerms</a> <a id="13102" href="Tactic.RingSolver.html#13018" class="Bound">`ring</a>

  <a id="13111" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13158" href="Tactic.RingSolver.html#13158" class="Bound">listOfVariables′</a> <a id="13175" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13177" href="Tactic.RingSolver.html#11440" class="Function">checkIsListOfVariables</a> <a id="13200" href="Tactic.RingSolver.html#13018" class="Bound">`ring</a> <a id="13206" href="Tactic.RingSolver.html#12991" class="Bound">variables</a>
  <a id="13218" href="Agda.Builtin.Reflection.html#9504" class="Postulate">commitTC</a>
  <a id="13229" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="13234" href="Tactic.RingSolver.html#13234" class="Bound">variableIndices</a> <a id="13250" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13252" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="13257" class="Symbol">(</a><a id="13258" href="Tactic.RingSolver.html#11634" class="Function">getVariableIndices</a> <a id="13277" href="Tactic.RingSolver.html#13158" class="Bound">listOfVariables′</a><a id="13293" class="Symbol">)</a>
    <a id="13299" class="Keyword">where</a> <a id="13305" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="13313" class="Symbol">→</a> <a id="13315" href="Tactic.RingSolver.html#10948" class="Function">malformedArgumentListError</a> <a id="13342" href="Tactic.RingSolver.html#13158" class="Bound">listOfVariables′</a>

  <a id="13362" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13400" href="Tactic.RingSolver.html#13400" class="Bound">hole′</a> <a id="13406" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13408" href="Agda.Builtin.Reflection.html#8555" class="Postulate">inferType</a> <a id="13418" href="Tactic.RingSolver.html#13006" class="Bound">hole</a> <a id="13423" href="Reflection.TCM.Syntax.html#623" class="Function Operator">&gt;&gt;=</a> <a id="13427" href="Agda.Builtin.Reflection.html#8670" class="Postulate">reduce</a>
  <a id="13436" href="Agda.Builtin.Maybe.html#156" class="InductiveConstructor">just</a> <a id="13441" class="Symbol">(</a><a id="13442" href="Tactic.RingSolver.html#13442" class="Bound">lhs</a> <a id="13446" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="13448" href="Tactic.RingSolver.html#13448" class="Bound">rhs</a> <a id="13452" href="Data.Vec.Base.html#1141" class="InductiveConstructor Operator">∷</a> <a id="13454" href="Data.Vec.Base.html#1122" class="InductiveConstructor">[]</a><a id="13456" class="Symbol">)</a> <a id="13458" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13460" href="Reflection.TCM.html#1025" class="Postulate">pure</a> <a id="13465" class="Symbol">(</a><a id="13466" href="Tactic.RingSolver.html#1810" class="Function">getVisibleArgs</a> <a id="13481" class="Number">2</a> <a id="13483" href="Tactic.RingSolver.html#13400" class="Bound">hole′</a><a id="13488" class="Symbol">)</a>
    <a id="13494" class="Keyword">where</a> <a id="13500" href="Agda.Builtin.Maybe.html#177" class="InductiveConstructor">nothing</a> <a id="13508" class="Symbol">→</a> <a id="13510" href="Tactic.RingSolver.html#11206" class="Function">malformedGoalError</a> <a id="13529" href="Tactic.RingSolver.html#13400" class="Bound">hole′</a>

  <a id="13538" href="Tactic.RingSolver.html#13538" class="Bound">solution</a> <a id="13547" href="Reflection.TCM.Syntax.html#623" class="Function Operator">←</a> <a id="13549" href="Tactic.RingSolver.html#11862" class="Function">constructSolution</a> <a id="13567" href="Tactic.RingSolver.html#13018" class="Bound">`ring</a> <a id="13573" href="Tactic.RingSolver.html#13065" class="Bound">operatorTerms</a> <a id="13587" href="Tactic.RingSolver.html#13234" class="Bound">variableIndices</a> <a id="13603" href="Tactic.RingSolver.html#13442" class="Bound">lhs</a> <a id="13607" href="Tactic.RingSolver.html#13448" class="Bound">rhs</a>
  <a id="13613" href="Agda.Builtin.Reflection.html#8452" class="Postulate">unify</a> <a id="13619" href="Tactic.RingSolver.html#13006" class="Bound">hole</a> <a id="13624" href="Tactic.RingSolver.html#13538" class="Bound">solution</a>

<a id="13634" class="Keyword">macro</a>
  <a id="solve"></a><a id="13642" href="Tactic.RingSolver.html#13642" class="Function">solve</a> <a id="13648" class="Symbol">:</a> <a id="13650" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="13655" class="Symbol">→</a> <a id="13657" href="Agda.Builtin.Reflection.html#471" class="Postulate">Name</a> <a id="13662" class="Symbol">→</a> <a id="13664" href="Agda.Builtin.Reflection.html#4670" class="Datatype">Term</a> <a id="13669" class="Symbol">→</a> <a id="13671" href="Agda.Builtin.Reflection.html#8279" class="Postulate">TC</a> <a id="13674" href="Agda.Builtin.Unit.html#158" class="Record">⊤</a>
  <a id="13678" href="Tactic.RingSolver.html#13642" class="Function">solve</a> <a id="13684" class="Symbol">=</a> <a id="13686" href="Tactic.RingSolver.html#12939" class="Function">solve-macro</a>
</pre></body></html>